#!/usr/bin/env python3
"""
Generate requirements-dev.txt from EXTRAS_REQUIRE or extras_require in setup.py
without executing setup.py (uses AST parsing).

Usage:
    python tools/generate_requirements_dev.py --output=requirements-dev.txt
"""
from __future__ import annotations
import ast
import argparse
from typing import List, Optional


def literal_value(node: ast.AST):
    if isinstance(node, ast.Constant):  # py3.8+
        return node.value
    if isinstance(node, ast.Str):
        return node.s
    if isinstance(node, ast.List):
        return [literal_value(elt) for elt in node.elts]
    if isinstance(node, ast.Tuple):
        return tuple(literal_value(elt) for elt in node.elts)
    if isinstance(node, ast.Dict):
        keys = [literal_value(k) for k in node.keys]
        vals = [literal_value(v) for v in node.values]
        return dict(zip(keys, vals))
    # fallback: unsupported
    raise ValueError(f"Unsupported AST node for literal extraction: {type(node).__name__}")


def find_extras_require(tree: ast.AST) -> Optional[dict]:
    # Look for top-level assignments named EXTRAS_REQUIRE or extras_require
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id in ("EXTRAS_REQUIRE", "extras_require"):
                    try:
                        val = literal_value(node.value)
                        if isinstance(val, dict):
                            return val
                    except Exception:
                        pass
    # Also attempt to find a call to setup(..., extras_require=...) with a literal dict
    for node in tree.body:
        if isinstance(node, ast.Expr) and isinstance(node.value, ast.Call):
            call = node.value
            func = call.func
            if isinstance(func, ast.Name) and func.id == "setup" or getattr(func, "attr", "") == "setup":
                for kw in call.keywords:
                    if kw.arg == "extras_require":
                        try:
                            val = literal_value(kw.value)
                            if isinstance(val, dict):
                                return val
                        except Exception:
                            pass
    return None


def normalize_requirement(req: str) -> str:
    return req.strip()


def write_requirements(develop_list: List[str], out_path: str):
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("# Autogenerated from setup.py extras_require['develop']\n")
        for r in develop_list:
            if r and r.strip():
                f.write(normalize_requirement(r) + "\n")


def main():
    p = argparse.ArgumentParser()
    p.add_argument("--setup", default="setup.py", help="Path to setup.py")
    p.add_argument("--output", default="requirements-dev.txt", help="Output requirements file")
    args = p.parse_args()

    with open(args.setup, "r", encoding="utf-8") as fh:
        src = fh.read()
    tree = ast.parse(src, filename=args.setup)

    extras = find_extras_require(tree)
    if not extras:
        raise SystemExit("Could not find EXTRAS_REQUIRE / extras_require as a literal dict in setup.py")

    develop = extras.get("develop") or extras.get("dev") or extras.get("developers")
    if not develop:
        raise SystemExit("No 'develop' extras found in extras_require")

    if not isinstance(develop, (list, tuple)):
        raise SystemExit("develop extras is not a list/tuple literal; cannot auto-generate safely")

    write_requirements(list(develop), args.output)
    print(f"Wrote {len(develop)} entries to {args.output}")


if __name__ == "__main__":
    main()
